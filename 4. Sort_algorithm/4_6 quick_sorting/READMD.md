# Quick Sorting

퀵 정렬은 가장 빠른 정렬 알고리즘으로 알려져 있으며 널리 사용되고 있음.

고안자: 찰스 A. R. 호어

예제) a= [5, 7, 1, 4, 6, 2, 3, 9, 8]

그룹을 먼저 나눔. 이때 피벗을 하나 선택하여 해당 피벗 이하인 원소들, 피벗 이상인 원소들로 배열을 나눔 (이때 피벗은 가운데 6이라고 해보자)

이때 배열 왼쪽을 pl이라고 하며, 배열 오른쪽 끝을 pr이라고 할때...

-> a[pl] >= x가 성립하는 원소를 찾을 때까지 pl을 오른쪽 방향으로 스캔하게 됨
-> a[pr] <= x가 성립하는 원소를 찾을 때까지 pr을 왼쪽 방향으로 스캔하게 됨.

## Step 1)

pl은 피벗 이상인 원소에, pr은 피벗 이하인 원소에 위치함.

즉, pl은 왼쪽의 7값에 위치하게 될것이며, pr은 오른쪽 끝에서 시작하게 되어 3에 위치하게 될것임.

이때 pl과 pr값을 서로 바꿈 -> a = [5, 3, 1, 4, 6, 2, 7, 9, 8]

## Step 2)

다시 pl과 pr을 이용한 스캔을 a 배열에서 진행함

이번에는 pl은 6보다 큰 숫자가 없다가 6을 만나게 되며, pr은 6보다 작은 숫자를 찾다가 2를 만나게됨

이때 pl과 pr값을 서로 바꿈 -> a = [5, 3, 1, 4, 2, 6, 7, 9, 8]

이로서 5, 3, 1, 4, 2는 피벗 6값을 기준으로 왼쪽에 정렬됨. 그리고 6기준으로 오른쪽은 더 큰숫자들만 남게됨.

이때 한칸씩 더 전진하게 되면 pr과 pl이 교차하므로 종료하게 됨

## step 3)

아래와 같이 2그룹으로 나누게 됨.

피벗 이하인 그룹: a[0], ... ,a[pl-1] -> a_l = [5, 3, 4, 2, 1]
피벗 이상인 그룹: a[pr + 1], ... , a[n-1] -> a_r = [6, 8, 9, 7]

## step 4)

a_l, a_r 그룹 또한 각각 step 1,2,3을 따르게 된다.

a_l -> 피벗이 4가 되며 1과 5를 먼저 바꾸고, 그다음 2와 4를 바꾸게 된다 -> 1, 3, 2, 4, 5

a_r -> 피벗이 7이 되며 이를 기준으로 바꾼다면 -> 6, 7, 9, 8이 됨 











